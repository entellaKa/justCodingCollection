"""
*******후위 표기식 계산기*******
1. 입력된 식을 괄호로 묶어 계산 순서를 알기 쉽게 정리한다.
1-1) 괄호를 묶는 우선 순위는 계산 순서와 마찬가지로 "(,)" > "*,/,%" > "+,-" 으로 내림차순이다.
1-2) 괄호 바로 전후로 숫자가 있다면 중간에 곱하기를 추가한다
1-3) 음수 입력을 주의한다 (아직 미구현)
2. 정리된 식을 후위 표기식으로 바꿔준다
3. 바뀐 식을 계산한다.

축약어 :  p - plus or minus, m - multiply or division, b - bracket, n - number
"""

temp = "3+4*(1+4/2+2*3)" #(3+(4*(1+(4/2)+(2*3))))
#temp = "3+4+7*(1+4/2+2*3)+(25/37)"
#temp = "123456+345678*567890"
#temp = "1*2*3*4*8*9"

storage = []

def checkOperator(c): #check this character is operator
	if c == "+" or c == "-" or c == "*" or c == "/" or c == "%":
		return True
	else:
		return False
    
def standardization(formula):
    fixedFormula = ""
    num = ""
    storage = []
    
    for i in range(len(formula)):
        if formula[i].isnumeric():
            num+=formula[i]
        elif formula[i] == "(":
            if not num == "":
                storage.append(num) #extract a number from formula 식에서 숫자를 추출한다
                fixedFormula += "n*"
                num == ""
            fixedFormula += "("
        elif formula[i] == ")":
            if not num == "":
                fixedFormula += "n"
                storage.append(num) #extract a number from formula 식에서 숫자를 추출한다
                num = ""
            fixedFormula += ")"
            if i+1 < len(formula):
                if formula[i+1].isnumeric():
                    fixedFormula += "*"
        elif checkOperator(formula[i]):
            if not num == "":
                fixedFormula += "n"
                storage.append(num) #extract a number from formula 식에서 숫자를 추출한다
                num = ""
            else:
                #음수 입력 구현
                pass
            fixedFormula += formula[i]
    return fixedFormula 
"""*******************cleer*******************"""

def abbreviateBracket(formula):
    count = 1
    returnFormula = ""
    for i in range(len(formula)):
        if formula[i] == "(":
            count += 1
            abbreviateBracket(formula[i+1:])
        elif formula[i] == ")":
            count -= 1
            if count == 0:
                ##############################################################################################
                 abbreviateMultiply(formula[:i])
                return formula[:i]
    return formula

def abbreviateMultiply(formula):
    returnFormula = ""
    ex = ""
    stack = []
    for i in range(len(formula)):
        if formula[i] == "*" or formula[i] == "/" or formula[i] == "%":
            if ex == "":
                stack.append("(m*{})".format(formula[i+1]))
            else:
                returnFormula += "m"
                stack.append("({}*{})".format(formula[i-1], formula[i+1]))
            ex = "pass"
        else:
            if ex == "pass":
                ex = ""
            else:
                returnFormula += ex
                ex = formula[i]

def abbreviatePlus(formula): #더하기 빼기는 줄일필요 없이 바로 괄호로 묶어 줘도 상관 없음
    returnFormula = "("+formula[:3]+")"
    '''
    ex = ""
    stack = []
    
    for i in range(len(formula)):
    """
        if formula[i] == "+" or formula[i] == "-": 
            if ex == "":
                stack.append("(p*{})".format(formula[i+1]))
            else:
                returnFormula += "p"
                stack.append("({}*{})".format(formula[i-1], formula[i+1]))
            ex = "pass"
        else:
            if ex == "pass":
                ex = ""
            else:
                returnFormula += ex
                ex = formula[i]
                """
                '''
    n = (len(formula)-3)/2
    returnFormula = "(" * n + returnFormula
    for i in range(3:n+3):
        returnFormula += formula[2*i:2*i+1] + ")"
        
    return returnFormula ###################################################################################################
        
                
def wrapping(formula):
    newFormula = ""
    count  = 1 #BracketCount
    
    for i in range(len(formula)):
        if formula[i] == "x":
            pass
        elif formula[i] == "(":
            
        elif checkOperator(formula[i]):
            
        elif formula[i] == ")":
            return formula[:i-1], newFromula
        #newformula += formula[i]
    return newFormula

def organize(formula): #function using the bracket to organize the calculation order//괄호로 식의 계산 순서를 정리해주는 함수
    noformula = standardization(formula)
    wrappedFormula = wrapping(noformula)
    newFormula = wrappedFormula
    
    return newFormula
	
def postfix(formula):
	postfixedFormula = ""
	opStack = []
	for i in range(len(formula)):
		if formula[i].isnumeric():
			postfixedFormula += formula[i]
		elif formula[i] == "(":
			pass
		elif formula[i] == ")":
			postfixedFormula += " " + opStack.pop()
		else:
			opStack.append(formula[i])
			postfixedFormula += " "
			print(formula[i])
			print(opStack)
	print(opStack)
	return postfixedFormula
	
def calculate(formula):
	stack = []
	num = ""
	
	for i in range(len(formula)):
		if formula[i] == " ":
			stack.append(int(num))
			num = ""
		elif formula[i].isnumeric():
			num += formula[i]
		else:
			if formula[i] == "+":
				num = stack.pop() + stack.pop()
			elif formula[i] == "-":
				n = stack.pop()
				num = stack.pop() - n
			elif formula[i] == "*":
				num = stack.pop() * stack.pop()
			elif formula[i] == "/":
				n = stack.pop()
				num = stack.pop() / n
			elif formula[i] == "%":
				n = stack.pop()
				num = stack.pop() % n
	print(stack)
	return num

f = organize(temp)
print("식 정리 : "+f)
'''g = postfix(f)
print("식 재구성 :"+g)
h = calculate(g)
print("식 결과값 :"+str(h))'''
